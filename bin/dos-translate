#!/usr/bin/env node

// Little hack to include `NODE_PATH=.`
var path = require('path');
require('node-path')(module, [path.resolve('.')]);

var fs = require('fs');
var arrDiff = require('arr-diff');
var config = require('lib/config');
var jsonFile = require('json-file-plus');

// Load the list of available languages.
var LANGS_FOLDER = 'lib/translations/lib'
var languages = fs.readdirSync(LANGS_FOLDER).map(function(v){
  return v.replace('.json', '');
});

/*
 * Extend proto of JSONFile object
 */

(function(){
  function sort(old) {
    if (typeof(old) !== 'object' && old !== null) {
        return old;
    }
    var copy = Array.isArray(old) ? [] : {};
    var keys = Object.keys(old).sort();
    keys.forEach(function(key) {
        copy[key] = sort(old[key]);
    });
    return copy;
  }

  jsonFile.JSONFile.prototype.sort = function(){
    this.data = sort(this.data)
  }
})();

/*
 * Utility Functions
 */

function halt(err){
  if (err) console.error(err)
  process.exit(1);
}

function getLangPath(lang) {
  return path.join(LANGS_FOLDER, lang + '.json');
}

function getLang(lang) {
  return require(getLangPath(lang));
}

function getLangKeys(lang) {
  return Object.keys(getLang(lang));
}

function forEachLanguageFile(langs, cb) {
  return langs.forEach(function(lang){
    jsonFile(getLangPath(lang), function(err, file) {
      if (err) return halt(err);
      cb.call(file, lang, file);
    });
  });
}

function defaultToParam(opts) {
  if (!opts.to || !opts.to.length) {
    opts.to = languages.filter(function(v){ return v !== opts.from; })
  }
}

/*
 * Commands
 */

function commandListMissing(opts) {
  defaultToParam(opts)

  var fromKeys = getLangKeys(opts.from);

  opts.to.forEach(function(lang){
    var toKeys = getLangKeys(lang);
    var missing = arrDiff(fromKeys, toKeys);

    if (!missing.length) return;

    console.log('Missing ' + missing.length + ' keys on `' + lang + '`:');

    missing.forEach(function(k){
      console.log('  - ' + k);
    });
  });
}

function commandTranslateMissing(opts) {
  defaultToParam(opts)

  var googleTranslate = require('google-translate')(config.googleAPIKey);
  var fromLang = getLang(opts.from);
  var fromKeys = getLangKeys(opts.from);

  var missings = {}
  var langs = opts.to.filter(function(lang){
    var toKeys = getLangKeys(lang);
    var missing = arrDiff(fromKeys, toKeys);

    if (missing.length) missings[lang] = missing;

    return !!missing.length;
  });


  forEachLanguageFile(langs, function(lang, file){
    console.log('Translating ' + missings[lang].length + ' missing keys on `' + lang + '`:');

    var edited = false;
    var format_regex = /%[a-z]/

    missings[lang].forEach(function(k){
      if (format_regex.test(fromLang[k])) {
        console.warn('  Couldnt translate `' + k + '`, it has a variable defined with % format.')
        return
      }

      googleTranslate.translate(fromLang[k], opts.from, lang, callback);

      function callback(err, translation) {
        if (err) return halt(err);

        var t = {};
        t[k] = translation.translatedText;
        file.set(t);
        console.log('  "' + k + '": "' + translation.translatedText + '"');

        edited = true;
      }
    });

    if (edited) {
      file.sort();
      file.save().then(function() {
        console.log('Done!');
      }).catch(function(err) {
        halt(err);
      });
    }
  });
}

function commandDeleteKey(opts) {
  var langs = opts.from ? opts.from : languages

  forEachLanguageFile(langs, function(lang, file){
    console.log('Deleting keys from `' + lang + '`:');

    opts.key.forEach(function(k){
      if (!file.data[k]) return;
      file.data[k] = undefined;
      console.log('  "' + k + '"');
    });

    file.save().then(function() {
      console.log('Done!');
    }).catch(function(err) {
      halt(err);
    });
  });
}

function commandRenameKey(opts) {
  var langs = opts.from ? opts.from : languages

  forEachLanguageFile(langs, function(lang, file){
    console.log('Renaming keys from `' + lang + '`:');

    if (opts.key.length !== opts.name.length) {
      halt('Have to provide the same amount of keys and names.');
    }

    var edited = false;

    opts.key.forEach(function(k, i){
      if (!file.data[k]) return;

      var name = opts.name[i];
      var value = file.data[k];

      if (k === name) return;

      file.data[k] = undefined;
      file.data[name] = value;

      edited = true;

      console.log('  "' + k + '" => "' + name + '"');
    });

    if (edited) {
      file.sort();
      file.save().then(function() {
        console.log('Done!');
      }).catch(function(err) {
        halt(err);
      });
    }
  });
}

/*
 * Definition of terminal interface
 */

var nomnom = require('nomnom');

nomnom.command('list-missing')
  .option('from', {
    abbr: 'f',
    help: 'Base language to use the keys as reference.',
    choices: languages,
    required: true
  })
  .option('to', {
    abbr: 't',
    help: 'Target language, will default to all other languages.',
    choices: languages,
    required: false,
    list: true
  })
  .callback(commandListMissing)
  .help('Find all the missing keys.');

nomnom.command('translate-missing')
  .option('from', {
    abbr: 'f',
    help: 'Base language to use as reference.',
    choices: languages,
    required: true
  })
  .option('to', {
    abbr: 't',
    help: 'Target language, will default to all other languages.',
    choices: languages,
    required: false,
    list: true
  })
  .callback(commandTranslateMissing)
  .help('Translate missing keys.');

nomnom.command('delete-key')
  .option('key', {
    abbr: 'k',
    help: 'Key(s) to delete.',
    required: true,
    list: true
  })
  .option('from', {
    abbr: 'f',
    help: 'Target language(s), will default to all languages.',
    choices: languages,
    required: false,
    list: true
  })
  .callback(commandDeleteKey)
  .help('Delete a given key from selected language files.');

nomnom.command('rename-key')
  .option('key', {
    abbr: 'k',
    help: 'Key(s) to rename.',
    required: true,
    list: true
  })
  .option('name', {
    abbr: 'n',
    help: 'New name to set the key(s), keep in mind to have the same order as `--key` param.',
    required: true,
    list: true
  })
  .option('from', {
    abbr: 'f',
    help: 'Target language(s), will default to all languages.',
    choices: languages,
    required: false,
    list: true
  })
  .callback(commandRenameKey)
  .help('Rename a given key from selected language files.');

nomnom.nom();
